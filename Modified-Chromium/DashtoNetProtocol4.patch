diff --git a/net/base/host_mapping_rules.cc b/net/base/host_mapping_rules.cc
index fec058db4f7c1..47475719bd974 100644
--- a/net/base/host_mapping_rules.cc
+++ b/net/base/host_mapping_rules.cc
@@ -77,7 +77,8 @@ bool HostMappingRules::RewriteHost(HostPortPair* host_port) const {
 HostMappingRules::RewriteResult HostMappingRules::RewriteUrl(GURL& url) const {
   // Must be a valid and standard URL. Otherwise, Chrome might not know how to
   // find/replace the contained host or port.
-  DCHECK(url.is_valid());
+
+  DCHECK(url.is_valid()); 
   DCHECK(url.IsStandard());
   DCHECK(url.has_host());
 
diff --git a/net/base/load_flags.h b/net/base/load_flags.h
index d26eaedf401ec..c44207d5cd1b2 100644
--- a/net/base/load_flags.h
+++ b/net/base/load_flags.h
@@ -5,6 +5,9 @@
 #ifndef NET_BASE_LOAD_FLAGS_H_
 #define NET_BASE_LOAD_FLAGS_H_
 
+#include "base/containers/queue.h" 
+#include <memory>
+
 namespace net {
 
 // These flags provide metadata about the type of the load request.  They are
diff --git a/net/http/http_network_transaction.cc b/net/http/http_network_transaction.cc
index 7b692f35088d5..25bb0c62e36af 100644
--- a/net/http/http_network_transaction.cc
+++ b/net/http/http_network_transaction.cc
@@ -246,7 +246,7 @@ int HttpNetworkTransaction::Start(const HttpRequestInfo* request_info,
     DCHECK(response_.unused_since_prefetch);
     response_.restricted_prefetch = true;
   }
-
+  
   next_state_ = STATE_NOTIFY_BEFORE_CREATE_STREAM;
   int rv = DoLoop(OK);
   if (rv == ERR_IO_PENDING)
diff --git a/net/http/http_request_info.h b/net/http/http_request_info.h
index d79c9eb8ab4ec..98d067226396b 100644
--- a/net/http/http_request_info.h
+++ b/net/http/http_request_info.h
@@ -41,6 +41,9 @@ struct NET_EXPORT HttpRequestInfo {
 
   bool IsConsistent() const;
 
+
+   bool preferredProtocol_ = false;
+
   // The requested URL.
   GURL url;
 
diff --git a/net/http/http_stream_factory_job_controller.cc b/net/http/http_stream_factory_job_controller.cc
index b7ceaef9a38a1..a082fd0d4a66b 100644
--- a/net/http/http_stream_factory_job_controller.cc
+++ b/net/http/http_stream_factory_job_controller.cc
@@ -21,7 +21,7 @@
 #include "net/base/net_errors.h"
 #include "net/base/privacy_mode.h"
 #include "net/base/proxy_chain.h"
-#include "net/base/proxy_string_util.h"
+#include "net/base/proxy_string_util.h" 
 #include "net/base/session_usage.h"
 #include "net/base/url_util.h"
 #include "net/http/bidirectional_stream_impl.h"
@@ -40,8 +40,11 @@
 #include "url/scheme_host_port.h"
 #include "url/url_constants.h"
 
+
+
 namespace net {
 
+
 namespace {
 
 // Returns parameters associated with the proxy resolution.
@@ -155,6 +158,9 @@ HttpStreamFactory::JobController::JobController(
       net_log_(NetLogWithSource::Make(
           session->net_log(),
           NetLogSourceType::HTTP_STREAM_JOB_CONTROLLER)) {
+
+  DVLOG(0) << "HttpRequestInfo->protocol in JobController Constructor : " << http_request_info.preferredProtocol_ << std::endl; 
+  activeProtocol = http_request_info.preferredProtocol_;
   DCHECK(factory_);
   DCHECK(session_);
   DCHECK(job_factory_);
@@ -184,6 +190,7 @@ HttpStreamFactory::JobController::JobController(
     dict.Set("allowed_bad_certs", std::move(allowed_bad_certs_list));
     return dict;
   });
+
 }
 
 HttpStreamFactory::JobController::~JobController() {
@@ -407,10 +414,21 @@ void HttpStreamFactory::JobController::OnQuicHostResolution(
 
 void HttpStreamFactory::JobController::OnStreamFailed(Job* job, int status) {
   DCHECK_NE(OK, status);
+
+  if ( (job->job_type() == MAIN && this->activeProtocol) || ( job->job_type() == ALTERNATIVE && !this->activeProtocol) ){
+    // Desired output --> simply return
+    return;
+  }
+  
+  std::string jobName = ( this->activeProtocol ) ? "HTTP3" : "HTTP2";
   if (job->job_type() == MAIN) {
+
+    DVLOG(0) << "MAIN JOB FAILED -> Expected " << jobName << std::endl;
     DCHECK_EQ(main_job_.get(), job);
     main_job_net_error_ = status;
   } else if (job->job_type() == ALTERNATIVE) {
+    DVLOG(0) << "ALT JOB FAILED -> Expected " << jobName << std::endl;
+
     DCHECK_EQ(alternative_job_.get(), job);
     DCHECK_NE(kProtoUnknown, alternative_service_info_.protocol());
     alternative_job_net_error_ = status;
@@ -831,12 +849,177 @@ int HttpStreamFactory::JobController::DoResolveProxyComplete(int rv) {
   return rv;
 }
 
-int HttpStreamFactory::JobController::DoCreateJobs() {
+//Original
+// int HttpStreamFactory::JobController::DoCreateJobs() {
+//   DCHECK(!main_job_);
+//   DCHECK(!alternative_job_);
+//   DCHECK(origin_url_.is_valid());
+//   DCHECK(origin_url_.IsStandard());
+
+
+//   url::SchemeHostPort destination(origin_url_);
+//   DCHECK(destination.IsValid());
+//   ConvertWsToHttp(destination);
+
+//   // Create an alternative job if alternative service is set up for this domain.
+//   // This is applicable even if the connection will be made via a proxy.
+//     alternative_service_info_ = GetAlternativeServiceInfoFor(
+//         http_request_info_url_, request_info_, delegate_, stream_type_);
+
+//   quic::ParsedQuicVersion quic_version = quic::ParsedQuicVersion::Unsupported();
+//   if (alternative_service_info_.protocol() == kProtoQUIC) {
+//     quic_version =
+//         SelectQuicVersion(alternative_service_info_.advertised_versions());
+//     DCHECK_NE(quic_version, quic::ParsedQuicVersion::Unsupported());
+//   }
+
+//   if (base::FeatureList::IsEnabled(features::kHappyEyeballsV3) &&
+//       proxy_info_.is_direct() && !is_websocket_) {
+//     SwitchToHttpStreamPool(quic_version);
+//     return OK;
+//   }
+
+//   // Getting ALPN for H3 from DNS has a lot of preconditions. Among them:
+//   // - proxied connections perform DNS on the proxy, so they can't get supported
+//   //   ALPNs from DNS
+//   const bool dns_alpn_h3_job_enabled =
+//       !HttpStreamFactory::Job::OriginToForceQuicOn(
+//           *session_->context().quic_context->params(), destination) &&
+//       enable_alternative_services_ &&
+//       session_->params().use_dns_https_svcb_alpn &&
+//       base::EqualsCaseInsensitiveASCII(origin_url_.scheme(),
+//                                        url::kHttpsScheme) &&
+//       session_->IsQuicEnabled() && proxy_info_.is_direct() &&
+//       !session_->http_server_properties()->IsAlternativeServiceBroken(
+//           GetAlternativeServiceForDnsJob(origin_url_),
+//           request_info_.network_anonymization_key);
+
+//   if (is_preconnect_) {
+//     // Due to how the socket pools handle priorities and idle sockets, only IDLE
+//     // priority currently makes sense for preconnects. The priority for
+//     // preconnects is currently ignored (see RequestSocketsForPool()), but could
+//     // be used at some point for proxy resolution or something.
+//     // Note: When `dns_alpn_h3_job_enabled` is true, we create a
+//     // PRECONNECT_DNS_ALPN_H3 job. If no matching HTTPS DNS ALPN records are
+//     // received, the PRECONNECT_DNS_ALPN_H3 job will fail with
+//     // ERR_DNS_NO_MATCHING_SUPPORTED_ALPN, and `preconnect_backup_job_` will
+//     // be started in OnPreconnectsComplete().
+//     std::unique_ptr<Job> preconnect_job = job_factory_->CreateJob(
+//         this, dns_alpn_h3_job_enabled ? PRECONNECT_DNS_ALPN_H3 : PRECONNECT,
+//         session_, request_info_, IDLE, proxy_info_, allowed_bad_certs_,
+//         destination, origin_url_, is_websocket_, enable_ip_based_pooling_,
+//         net_log_.net_log());
+//     // When there is an valid alternative service info, and `preconnect_job`
+//     // has no existing QUIC session, create a job for the alternative service.
+//     if (alternative_service_info_.protocol() != kProtoUnknown &&
+//         !preconnect_job->HasAvailableQuicSession()) {
+//       GURL alternative_url = CreateAltSvcUrl(
+//           origin_url_, alternative_service_info_.host_port_pair());
+//       RewriteUrlWithHostMappingRules(alternative_url);
+
+//       url::SchemeHostPort alternative_destination =
+//           url::SchemeHostPort(alternative_url);
+//       ConvertWsToHttp(alternative_destination);
+
+//       main_job_ = job_factory_->CreateJob(
+//           this, PRECONNECT, session_, request_info_, IDLE, proxy_info_,
+//           allowed_bad_certs_, std::move(alternative_destination), origin_url_,
+//           is_websocket_, enable_ip_based_pooling_, session_->net_log(),
+//           alternative_service_info_.protocol(), quic_version);
+//     } else {
+//       main_job_ = std::move(preconnect_job);
+
+//       if (dns_alpn_h3_job_enabled) {
+//         preconnect_backup_job_ = job_factory_->CreateJob(
+//             this, PRECONNECT, session_, request_info_, IDLE, proxy_info_,
+//             allowed_bad_certs_, std::move(destination), origin_url_,
+//             is_websocket_, enable_ip_based_pooling_, net_log_.net_log());
+//       }
+//     }
+//     main_job_->Preconnect(num_streams_);
+//     return OK;
+//   }
+//   main_job_ = job_factory_->CreateJob(
+//       this, MAIN, session_, request_info_, priority_, proxy_info_,
+//       allowed_bad_certs_, std::move(destination), origin_url_, is_websocket_,
+//       enable_ip_based_pooling_, net_log_.net_log());
+
+//   // Alternative Service can only be set for HTTPS requests while Alternative
+//   // Proxy is set for HTTP requests.
+//   // The main job may use HTTP/3 if the origin is specified in
+//   // `--origin-to-force-quic-on` switch. In that case, do not create
+//   // `alternative_job_` and `dns_alpn_h3_job_`.
+
+//   if ((alternative_service_info_.protocol() != kProtoUnknown) &&
+//       !main_job_->using_quic()) {
+//     DCHECK(origin_url_.SchemeIs(url::kHttpsScheme));
+//     DCHECK(!is_websocket_);
+
+
+//     DVLOG(1) << "Selected alternative service (host: "
+//              << alternative_service_info_.host_port_pair().host()
+//              << " port: " << alternative_service_info_.host_port_pair().port()
+//              << " version: " << quic_version << ")";
+
+//     GURL alternative_url = CreateAltSvcUrl(
+//         origin_url_, alternative_service_info_.host_port_pair());
+//     RewriteUrlWithHostMappingRules(alternative_url);
+
+//     url::SchemeHostPort alternative_destination =
+//         url::SchemeHostPort(alternative_url);
+//     ConvertWsToHttp(alternative_destination);
+
+//     alternative_job_ = job_factory_->CreateJob(
+//         this, ALTERNATIVE, session_, request_info_, priority_, proxy_info_,
+//         allowed_bad_certs_, std::move(alternative_destination), origin_url_,
+//         is_websocket_, enable_ip_based_pooling_, net_log_.net_log(),
+//         alternative_service_info_.protocol(), quic_version);
+//   }
+
+//   if (dns_alpn_h3_job_enabled && !main_job_->using_quic()) {
+//     DCHECK(!is_websocket_);
+//     url::SchemeHostPort dns_alpn_h3_destination =
+//         url::SchemeHostPort(origin_url_);
+//     dns_alpn_h3_job_ = job_factory_->CreateJob(
+//         this, DNS_ALPN_H3, session_, request_info_, priority_, proxy_info_,
+//         allowed_bad_certs_, std::move(dns_alpn_h3_destination), origin_url_,
+//         is_websocket_, enable_ip_based_pooling_, net_log_.net_log());
+//   }
+
+
+//   ClearInappropriateJobs();
+
+//   if (main_job_ && (alternative_job_ ||
+//                     (dns_alpn_h3_job_ &&
+//                      (!main_job_->TargettedSocketGroupHasActiveSocket() &&
+//                       !main_job_->HasAvailableSpdySession())))) {
+//     // We don't block |main_job_| when |alternative_job_| doesn't exists and
+//     // |dns_alpn_h3_job_| exists and an active socket is available for
+//     // |main_job_|. This is intended to make the fallback logic faster.
+//     main_job_is_blocked_ = true;
+//   }
+
+//   if (alternative_job_) {
+//     alternative_job_->Start(request_->stream_type());
+//   }
+
+//   if (dns_alpn_h3_job_) {
+//     dns_alpn_h3_job_->Start(request_->stream_type());
+//   }
+
+//   if (main_job_) {
+//     main_job_->Start(request_->stream_type());
+//   }
+//   return OK;
+// }
+
+int HttpStreamFactory::JobController::DoCreateJobs_Default() {
   DCHECK(!main_job_);
   DCHECK(!alternative_job_);
   DCHECK(origin_url_.is_valid());
   DCHECK(origin_url_.IsStandard());
 
+
   url::SchemeHostPort destination(origin_url_);
   DCHECK(destination.IsValid());
   ConvertWsToHttp(destination);
@@ -929,10 +1112,13 @@ int HttpStreamFactory::JobController::DoCreateJobs() {
   // The main job may use HTTP/3 if the origin is specified in
   // `--origin-to-force-quic-on` switch. In that case, do not create
   // `alternative_job_` and `dns_alpn_h3_job_`.
+
   if ((alternative_service_info_.protocol() != kProtoUnknown) &&
       !main_job_->using_quic()) {
     DCHECK(origin_url_.SchemeIs(url::kHttpsScheme));
     DCHECK(!is_websocket_);
+
+
     DVLOG(1) << "Selected alternative service (host: "
              << alternative_service_info_.host_port_pair().host()
              << " port: " << alternative_service_info_.host_port_pair().port()
@@ -963,6 +1149,7 @@ int HttpStreamFactory::JobController::DoCreateJobs() {
         is_websocket_, enable_ip_based_pooling_, net_log_.net_log());
   }
 
+
   ClearInappropriateJobs();
 
   if (main_job_ && (alternative_job_ ||
@@ -989,6 +1176,199 @@ int HttpStreamFactory::JobController::DoCreateJobs() {
   return OK;
 }
 
+
+// Modified
+int HttpStreamFactory::JobController::DoCreateJobs() {
+  std::string desiredURLPrefix = "https://sapnansl.site/Kartikey/dash2";
+  // std::string desiredURLPrefix = "https://sapnansl.site/chirag/dash-intelligent-browser-video";
+
+  std::string playlist = "https://sapnansl.site/Kartikey/dash2/playlist.mpd";
+  // std::string playlist = "https://sapnansl.site/chirag/dash-intelligent-browser-video/playlist.mpd";
+
+  // if this prefix exists in the origin_url link --> run modified DoCreateJobs
+  // else run original
+
+  DVLOG(0) << "Origin URL ( IN BEGINNING ): " << origin_url_.spec() << std::endl;
+  // return DoCreateJobs_Default();
+
+  if ( origin_url_.spec().compare(playlist) == 0 || origin_url_.spec().find(desiredURLPrefix) != 0 ){
+    DVLOG(0) << "Origin URL ( Type: Other ): " << origin_url_.spec() << std::endl;
+    return DoCreateJobs_Default();
+
+  }else{
+    DVLOG(0) << "Origin URL ( Type: Audio/Video ): " << origin_url_.spec() << std::endl;
+
+    DCHECK(!main_job_);
+    DCHECK(!alternative_job_);
+    DCHECK(origin_url_.is_valid());
+    DVLOG(0) << "FIRST CHECK PASSED" << std::endl;
+    DCHECK(origin_url_.IsStandard());
+
+    url::SchemeHostPort destination(origin_url_);
+    DCHECK(destination.IsValid());
+    ConvertWsToHttp(destination);
+
+    // Create an alternative job if alternative service is set up for this domain.
+    // This is applicable even if the connection will be made via a proxy.
+      alternative_service_info_ = GetAlternativeServiceInfoFor(
+          http_request_info_url_, request_info_, delegate_, stream_type_);
+
+    quic::ParsedQuicVersion quic_version = quic::ParsedQuicVersion::Unsupported();
+    if (alternative_service_info_.protocol() == kProtoQUIC) {
+      quic_version =
+          SelectQuicVersion(alternative_service_info_.advertised_versions());
+      DCHECK_NE(quic_version, quic::ParsedQuicVersion::Unsupported());
+    }
+
+    if (base::FeatureList::IsEnabled(features::kHappyEyeballsV3) &&
+        proxy_info_.is_direct() && !is_websocket_) {
+      SwitchToHttpStreamPool(quic_version);
+      return OK;
+    }
+
+    // Getting ALPN for H3 from DNS has a lot of preconditions. Among them:
+    // - proxied connections perform DNS on the proxy, so they can't get supported
+    //   ALPNs from DNS
+    const bool dns_alpn_h3_job_enabled =
+        !HttpStreamFactory::Job::OriginToForceQuicOn(
+            *session_->context().quic_context->params(), destination) &&
+        enable_alternative_services_ &&
+        session_->params().use_dns_https_svcb_alpn &&
+        base::EqualsCaseInsensitiveASCII(origin_url_.scheme(),
+                                        url::kHttpsScheme) &&
+        session_->IsQuicEnabled() && proxy_info_.is_direct() &&
+        !session_->http_server_properties()->IsAlternativeServiceBroken(
+            GetAlternativeServiceForDnsJob(origin_url_),
+            request_info_.network_anonymization_key);
+
+    if (is_preconnect_) {
+      // Due to how the socket pools handle priorities and idle sockets, only IDLE
+      // priority currently makes sense for preconnects. The priority for
+      // preconnects is currently ignored (see RequestSocketsForPool()), but could
+      // be used at some point for proxy resolution or something.
+      // Note: When `dns_alpn_h3_job_enabled` is true, we create a
+      // PRECONNECT_DNS_ALPN_H3 job. If no matching HTTPS DNS ALPN records are
+      // received, the PRECONNECT_DNS_ALPN_H3 job will fail with
+      // ERR_DNS_NO_MATCHING_SUPPORTED_ALPN, and `preconnect_backup_job_` will
+      // be started in OnPreconnectsComplete().
+      std::unique_ptr<Job> preconnect_job = job_factory_->CreateJob(
+          this, dns_alpn_h3_job_enabled ? PRECONNECT_DNS_ALPN_H3 : PRECONNECT,
+          session_, request_info_, IDLE, proxy_info_, allowed_bad_certs_,
+          destination, origin_url_, is_websocket_, enable_ip_based_pooling_,
+          net_log_.net_log());
+      // When there is an valid alternative service info, and `preconnect_job`
+      // has no existing QUIC session, create a job for the alternative service.
+      if (alternative_service_info_.protocol() != kProtoUnknown &&
+          !preconnect_job->HasAvailableQuicSession()) {
+        GURL alternative_url = CreateAltSvcUrl(
+            origin_url_, alternative_service_info_.host_port_pair());
+        RewriteUrlWithHostMappingRules(alternative_url);
+
+        url::SchemeHostPort alternative_destination =
+            url::SchemeHostPort(alternative_url);
+        ConvertWsToHttp(alternative_destination);
+
+        main_job_ = job_factory_->CreateJob(
+            this, PRECONNECT, session_, request_info_, IDLE, proxy_info_,
+            allowed_bad_certs_, std::move(alternative_destination), origin_url_,
+            is_websocket_, enable_ip_based_pooling_, session_->net_log(),
+            alternative_service_info_.protocol(), quic_version);
+      } else {
+        main_job_ = std::move(preconnect_job);
+
+        if (dns_alpn_h3_job_enabled) {
+          preconnect_backup_job_ = job_factory_->CreateJob(
+              this, PRECONNECT, session_, request_info_, IDLE, proxy_info_,
+              allowed_bad_certs_, std::move(destination), origin_url_,
+              is_websocket_, enable_ip_based_pooling_, net_log_.net_log());
+        }
+      }
+      main_job_->Preconnect(num_streams_);
+      return OK;
+    }
+    main_job_ = job_factory_->CreateJob(
+        this, MAIN, session_, request_info_, priority_, proxy_info_,
+        allowed_bad_certs_, std::move(destination), origin_url_, is_websocket_,
+        enable_ip_based_pooling_, net_log_.net_log());
+
+    // if ((alternative_service_info_.protocol() != kProtoUnknown) &&
+    //     !main_job_->using_quic()) {
+
+    if ( true ){
+      DCHECK(origin_url_.SchemeIs(url::kHttpsScheme));
+      DCHECK(!is_websocket_);
+
+      // DVLOG(0) << "Origin URL ( IN ALT CHECK ): " << origin_url_.spec() << std::endl;
+
+      DVLOG(1) << "Selected alternative service (host: "
+              << alternative_service_info_.host_port_pair().host()
+              << " port: " << alternative_service_info_.host_port_pair().port()
+              << " version: " << quic_version << ")";
+
+      GURL alternative_url = CreateAltSvcUrl(
+          origin_url_, alternative_service_info_.host_port_pair());
+      RewriteUrlWithHostMappingRules(alternative_url);
+
+      url::SchemeHostPort alternative_destination =  url::SchemeHostPort(alternative_url);
+      ConvertWsToHttp(alternative_destination);
+
+      // alternative_job_ = job_factory_->CreateJob(
+      //     this, ALTERNATIVE, session_, request_info_, priority_, proxy_info_,
+      //     allowed_bad_certs_, std::move(alternative_destination), origin_url_,
+      //     is_websocket_, enable_ip_based_pooling_, net_log_.net_log(),
+      //     alternative_service_info_.protocol(), quic_version);
+
+      alternative_job_ = job_factory_->CreateJob(
+          this, ALTERNATIVE, session_, request_info_, priority_, proxy_info_,
+          allowed_bad_certs_, std::move(alternative_destination), origin_url_,
+         false, enable_ip_based_pooling_, net_log_.net_log(),
+          kProtoQUIC, quic_version);
+    }
+
+    if (dns_alpn_h3_job_enabled && !main_job_->using_quic()) {
+      DCHECK(!is_websocket_);
+      url::SchemeHostPort dns_alpn_h3_destination =
+          url::SchemeHostPort(origin_url_);
+      dns_alpn_h3_job_ = job_factory_->CreateJob(
+          this, DNS_ALPN_H3, session_, request_info_, priority_, proxy_info_,
+          allowed_bad_certs_, std::move(dns_alpn_h3_destination), origin_url_,
+          is_websocket_, enable_ip_based_pooling_, net_log_.net_log());
+    }
+
+    // ClearInappropriateJobs();
+
+    if (main_job_ && (alternative_job_ ||
+                      (dns_alpn_h3_job_ &&
+                      (!main_job_->TargettedSocketGroupHasActiveSocket() &&
+                        !main_job_->HasAvailableSpdySession())))) {
+      // We don't block |main_job_| when |alternative_job_| doesn't exists and
+      // |dns_alpn_h3_job_| exists and an active socket is available for
+      // |main_job_|. This is intended to make the fallback logic faster.
+      DVLOG(0) << "MAIN JOB IS BLOCKED SET AS TRUE" << std::endl;
+      main_job_is_blocked_ = true;
+    }
+
+    if ( this->activeProtocol ){
+      DVLOG(0) << "DoCreateJobs: Require HTTP3" << std::endl;
+      if ( !alternative_job_ ) DVLOG(0) << "ALT NOT SET" << std::endl;
+      main_job_is_blocked_ = true;
+      alternative_job_->Start(request_->stream_type());
+
+
+    }else{
+
+      DVLOG(0) << "DoCreateJobs: Require HTTP2" << std::endl;
+      if ( !main_job_ ) DVLOG(0) << "MAIN NOT SET" << std::endl;
+      main_job_is_blocked_ = false;
+      main_job_->Start(request_->stream_type());
+
+    }
+
+    return OK;
+  } 
+ 
+}
+
 void HttpStreamFactory::JobController::ClearInappropriateJobs() {
   if (dns_alpn_h3_job_ && dns_alpn_h3_job_->HasAvailableQuicSession()) {
     // Clear |main_job_| and |alternative_job_| here not to start them when
@@ -1008,7 +1388,29 @@ void HttpStreamFactory::JobController::ClearInappropriateJobs() {
   }
 }
 
-void HttpStreamFactory::JobController::BindJob(Job* job) {
+// Original
+// void HttpStreamFactory::JobController::BindJob(Job* job) {
+//   DCHECK(request_);
+//   DCHECK(job);
+//   DCHECK(job == alternative_job_.get() || job == main_job_.get() ||
+//          job == dns_alpn_h3_job_.get());
+//   DCHECK(!job_bound_);
+//   DCHECK(!bound_job_);
+
+//   job_bound_ = true;
+//   bound_job_ = job;
+
+//   request_->net_log().AddEventReferencingSource(
+//       NetLogEventType::HTTP_STREAM_REQUEST_BOUND_TO_JOB,
+//       job->net_log().source());
+//   job->net_log().AddEventReferencingSource(
+//       NetLogEventType::HTTP_STREAM_JOB_BOUND_TO_REQUEST,
+//       request_->net_log().source());
+
+//   OrphanUnboundJob();
+// }
+
+void HttpStreamFactory::JobController::BindJob_Default(Job* job) {
   DCHECK(request_);
   DCHECK(job);
   DCHECK(job == alternative_job_.get() || job == main_job_.get() ||
@@ -1029,7 +1431,88 @@ void HttpStreamFactory::JobController::BindJob(Job* job) {
   OrphanUnboundJob();
 }
 
+
+void HttpStreamFactory::JobController::BindJob(Job* job) {
+
+  std::string desiredURLPrefix = "https://sapnansl.site/Kartikey/dash2";
+  std::string playlist = "https://sapnansl.site/Kartikey/dash2/playlist.mpd";
+
+
+  // BindJob_Default(job);
+  // return;
+
+  if ( origin_url_.spec().compare(playlist) == 0 || origin_url_.spec().find(desiredURLPrefix) != 0 ){
+    DVLOG(0) << "BindJob->Origin URL ( Type: Other ): " << origin_url_.spec() << std::endl;
+    return BindJob_Default(job);
+
+  }else
+  {
+    DVLOG(0) << "BindJob->Origin URL ( Type: Audio/Video ): " << origin_url_.spec() << std::endl;
+
+    DCHECK(request_);
+    DCHECK(job);
+    DCHECK(job == alternative_job_.get() || job == main_job_.get() ||
+          job == dns_alpn_h3_job_.get());
+    DCHECK(!job_bound_);
+    DCHECK(!bound_job_);
+    
+    if ( job->job_type() == 0 ){
+      // MAIN
+      if ( this->activeProtocol ){
+        // HTTP3 desired
+        job_bound_ = false;
+        bound_job_ = nullptr;
+        return;
+
+      }else{
+        // HTTP2 desired
+        job_bound_ = true;
+        bound_job_ = job;
+      }
+
+    }else if ( job-> job_type() == 1 ){
+      //Alternative
+      if ( this->activeProtocol ){
+        // HTTP3 desired
+        job_bound_ = true;
+        bound_job_ = job;
+
+      }else{
+        // HTTP2 desired
+        job_bound_ = false;
+        bound_job_ = nullptr;
+
+        return;
+      }
+
+    }else{
+      // Preconnect or PRECONNECT_DNS_ALPN_H3
+      // GO AS PLANNED
+      job_bound_ = true;
+      bound_job_ = job;
+    }
+
+    request_->net_log().AddEventReferencingSource(
+            NetLogEventType::HTTP_STREAM_REQUEST_BOUND_TO_JOB,
+            job->net_log().source());
+    job->net_log().AddEventReferencingSource(
+        NetLogEventType::HTTP_STREAM_JOB_BOUND_TO_REQUEST,
+        request_->net_log().source());
+
+    OrphanUnboundJob();
+  }
+}
+
+
+
 void HttpStreamFactory::JobController::OrphanUnboundJob() {
+
+  if (this->activeProtocol) {
+    DVLOG(0) << "OrphanUnbound : HTTP3" << std::endl;
+  } else {
+    DVLOG(0) << "OrphanUnbound : HTTP2" << std::endl;
+  }
+
   DCHECK(request_);
   DCHECK(bound_job_);
 
diff --git a/net/tools/quic/certs/generate-certs.sh b/net/tools/quic/certs/generate-certs.sh
index 18799c833cd29..e4466dfcccd47 100755
--- a/net/tools/quic/certs/generate-certs.sh
+++ b/net/tools/quic/certs/generate-certs.sh
@@ -28,7 +28,7 @@ try openssl req \
   -config ca.cnf
 
 try openssl x509 \
-  -req -days 3 \
+  -req -days 30 \
   -in out/2048-sha256-root.req \
   -signkey out/2048-sha256-root.key \
   -extfile ca.cnf \
@@ -54,7 +54,7 @@ try openssl pkcs8 \
 # Generate the leaf certificate to be valid for three days.
 try openssl ca \
   -batch \
-  -days 3 \
+  -days 30 \
   -extensions user_cert \
   -in out/leaf_cert.req \
   -out out/leaf_cert.pem \
diff --git a/net/url_request/url_request.cc b/net/url_request/url_request.cc
index 757210abbc348..d50f4736986bb 100644
--- a/net/url_request/url_request.cc
+++ b/net/url_request/url_request.cc
@@ -52,8 +52,9 @@
 #include "url/gurl.h"
 #include "url/origin.h"
 
-namespace net {
 
+namespace net {
+  
 namespace {
 
 // True once the first URLRequest was started.
@@ -554,6 +555,17 @@ void URLRequest::set_allow_credentials(bool allow_credentials) {
   }
 }
 
+
+void URLRequest::set_allow_protocol(bool allow_protocol) {
+  allow_protocol_ = allow_protocol;
+ 
+  if (allow_protocol_) {
+    DVLOG(0) << " HTTP3 will be used for the request" << std::endl;
+  } else {
+    DVLOG(0) << " HTTP2 will be used for the request" << std::endl;
+  }
+}
+
 void URLRequest::Start() {
   DCHECK(delegate_);
 
@@ -659,6 +671,7 @@ void URLRequest::StartJob(std::unique_ptr<URLRequestJob> job) {
     DCHECK(load_flags() & LOAD_DISABLE_CACHE);
     DCHECK(!allow_credentials_);
   }
+  DVLOG(0) << "Protocol field in StartJob() : " << allow_protocol_ << std::endl;
 
   net_log_.BeginEvent(NetLogEventType::URL_REQUEST_START_JOB, [&] {
     return NetLogURLRequestStartParams(
@@ -668,6 +681,12 @@ void URLRequest::StartJob(std::unique_ptr<URLRequestJob> job) {
   });
 
   job_ = std::move(job);
+  
+  // copying value from URLRequest CLass to URLRequestJob class
+  job_->SetProtocol(allow_protocol_);
+  // DVLOG(0) << "RequestProtocol in StartJob(): " << job_->RequestProtocol << std::endl;
+
+
   job_->SetExtraRequestHeaders(extra_request_headers_);
   job_->SetPriority(priority_);
   job_->SetRequestHeadersCallback(request_headers_callback_);
diff --git a/net/url_request/url_request.h b/net/url_request/url_request.h
index 27bec2da4899c..d9864f9676745 100644
--- a/net/url_request/url_request.h
+++ b/net/url_request/url_request.h
@@ -423,7 +423,9 @@ class NET_EXPORT URLRequest : public base::SupportsUserData {
   // still occur. Setting this will force the LOAD_DO_NOT_SAVE_COOKIES field to
   // be set in |load_flags_|. See https://crbug.com/799935.
   void set_allow_credentials(bool allow_credentials);
+  void set_allow_protocol(bool allow_protocol);
   bool allow_credentials() const { return allow_credentials_; }
+  bool allow_protocol() const { return allow_protocol_; }
 
   // Sets the upload data.
   void set_upload(std::unique_ptr<UploadDataStream> upload);
@@ -872,6 +874,8 @@ class NET_EXPORT URLRequest : public base::SupportsUserData {
 
   base::WeakPtr<URLRequest> GetWeakPtr();
 
+ 
+
  protected:
   // Allow the URLRequestJob class to control the is_pending() flag.
   void set_is_pending(bool value) { is_pending_ = value; }
@@ -1021,6 +1025,11 @@ class NET_EXPORT URLRequest : public base::SupportsUserData {
   // Whether the request is allowed to send credentials in general. Set by
   // caller.
   bool allow_credentials_ = true;
+
+  // Whether the request is allowed to use http3 as transport protocol. Set by
+  // caller.
+  bool allow_protocol_ = true;
+
   // Whether the request is eligible for using a <request initiator's site,
   // top-level site> storage access permission grant if one exists. Only set by
   // caller when constructed and will not change during redirects.
diff --git a/net/url_request/url_request_http_job.cc b/net/url_request/url_request_http_job.cc
index 59089072e7c97..d4aa34157b206 100644
--- a/net/url_request/url_request_http_job.cc
+++ b/net/url_request/url_request_http_job.cc
@@ -429,9 +429,16 @@ void URLRequestHttpJob::SetPriority(RequestPriority priority) {
     transaction_->SetPriority(priority_);
 }
 
+void URLRequestHttpJob::SetProtocol( bool RequestProtocol) {
+  RequestProtocol_ = RequestProtocol;
+ 
+}
+
 void URLRequestHttpJob::Start() {
   DCHECK(!transaction_.get());
 
+  request_info_.preferredProtocol_ = RequestProtocol_;
+
   request_info_.url = request_->url();
   request_info_.method = request_->method();
 
diff --git a/net/url_request/url_request_http_job.h b/net/url_request/url_request_http_job.h
index dc3e7ca637ce1..b5107cd2dcbc5 100644
--- a/net/url_request/url_request_http_job.h
+++ b/net/url_request/url_request_http_job.h
@@ -70,6 +70,10 @@ class NET_EXPORT_PRIVATE URLRequestHttpJob : public URLRequestJob {
 
   // Overridden from URLRequestJob:
   void SetPriority(RequestPriority priority) override;
+
+  // Modification
+  void SetProtocol(bool RequestProtocol ) override;
+
   void Start() override;
   void Kill() override;
   ConnectionAttempts GetConnectionAttempts() const override;
@@ -81,6 +85,10 @@ class NET_EXPORT_PRIVATE URLRequestHttpJob : public URLRequestJob {
     return priority_;
   }
 
+  bool RequestProtocol() const {
+    return RequestProtocol_;
+  }
+
  private:
   // For CookieRequestScheme histogram enum.
   FRIEND_TEST_ALL_PREFIXES(URLRequestHttpJobTest,
@@ -243,6 +251,9 @@ class NET_EXPORT_PRIVATE URLRequestHttpJob : public URLRequestJob {
 
   RequestPriority priority_ = DEFAULT_PRIORITY;
 
+  // Modification
+  bool RequestProtocol_ = false;
+
   HttpRequestInfo request_info_;
 
   // Used for any logic, e.g. DNS-based scheme upgrade, that needs to synthesize
diff --git a/net/url_request/url_request_job.cc b/net/url_request/url_request_job.cc
index a2aa3c3361410..c36c134788b50 100644
--- a/net/url_request/url_request_job.cc
+++ b/net/url_request/url_request_job.cc
@@ -103,7 +103,8 @@ void URLRequestJob::SetExtraRequestHeaders(const HttpRequestHeaders& headers) {
 
 void URLRequestJob::SetPriority(RequestPriority priority) {
 }
-
+void URLRequestJob::SetProtocol( bool RequestProtocol ) {
+}
 void URLRequestJob::Kill() {
   weak_factory_.InvalidateWeakPtrs();
   // Make sure the URLRequest is notified that the job is done.  This assumes
diff --git a/net/url_request/url_request_job.h b/net/url_request/url_request_job.h
index 87fdb2057a6e1..389a28bfa697e 100644
--- a/net/url_request/url_request_job.h
+++ b/net/url_request/url_request_job.h
@@ -65,6 +65,7 @@ class NET_EXPORT URLRequestJob {
     return request_;
   }
 
+
   // Sets the upload data, most requests have no upload data, so this is a NOP.
   // Job types supporting upload data will override this.
   virtual void SetUpload(UploadDataStream* upload_data_stream);
@@ -77,6 +78,10 @@ class NET_EXPORT URLRequestJob {
   // called, but also when the priority of the parent request changes.
   virtual void SetPriority(RequestPriority priority);
 
+
+  // MODIFICATION
+  virtual void SetProtocol(bool RequestProtocol );
+
   // If any error occurs while starting the Job, NotifyStartError should be
   // called asynchronously.
   // This helps ensure that all errors follow more similar notification code
diff --git a/services/network/cors/cors_url_loader.cc b/services/network/cors/cors_url_loader.cc
index 661cfee6c2204..085a0606b1532 100644
--- a/services/network/cors/cors_url_loader.cc
+++ b/services/network/cors/cors_url_loader.cc
@@ -1106,6 +1106,7 @@ void CorsURLLoader::StartNetworkRequest() {
   // network::URLLoader doesn't understand |kSameOrigin|.
   // TODO(crbug.com/40619226): Fix this.
   auto original_credentials_mode = request_.credentials_mode;
+  auto original_protocol_mode = request_.protocol_mode;
   if (original_credentials_mode == mojom::CredentialsMode::kSameOrigin) {
     request_.credentials_mode =
         CalculateCredentialsFlag(original_credentials_mode, response_tainting_)
@@ -1134,6 +1135,7 @@ void CorsURLLoader::StartNetworkRequest() {
       &CorsURLLoader::OnNetworkClientMojoDisconnect, base::Unretained(this)));
 
   request_.credentials_mode = original_credentials_mode;
+  request_.protocol_mode = original_protocol_mode;
 }
 
 void CorsURLLoader::HandleComplete(URLLoaderCompletionStatus status) {
diff --git a/services/network/public/cpp/resource_request.cc b/services/network/public/cpp/resource_request.cc
index b220ca953b1db..ae03992348a9b 100644
--- a/services/network/public/cpp/resource_request.cc
+++ b/services/network/public/cpp/resource_request.cc
@@ -15,6 +15,7 @@
 #include "services/network/public/mojom/trust_token_access_observer.mojom.h"
 #include "services/network/public/mojom/url_request.mojom.h"
 #include "services/network/public/mojom/web_bundle_handle.mojom.h"
+#include "base/logging.h"
 
 namespace network {
 
@@ -99,6 +100,7 @@ mojo::PendingRemote<mojom::SharedDictionaryAccessObserver> Clone(
 //  - both |lhs| and |rhs| are nullopt, or
 //  - neither is nullopt and they both contain equal values
 //
+
 bool OptionalTrustedParamsEqualsForTesting(
     const std::optional<ResourceRequest::TrustedParams>& lhs,
     const std::optional<ResourceRequest::TrustedParams>& rhs) {
@@ -252,6 +254,7 @@ ResourceRequest::ResourceRequest(const base::Location& location)
 ResourceRequest::ResourceRequest() = default;
 #endif
 ResourceRequest::ResourceRequest(const ResourceRequest& request) {
+  // DVLOG(0) << "The request once set from request conversion is: " << request.protocol_mode << std::endl; 
   TRACE_EVENT("loading", "ResourceRequest::ResourceRequest.copy_constructor");
   *this = request;
 }
@@ -285,6 +288,7 @@ bool ResourceRequest::EqualsForTesting(const ResourceRequest& request) const {
          mode == request.mode &&
          required_ip_address_space == request.required_ip_address_space &&
          credentials_mode == request.credentials_mode &&
+         protocol_mode == request.protocol_mode &&
          redirect_mode == request.redirect_mode &&
          fetch_integrity == request.fetch_integrity &&
          destination == request.destination &&
@@ -328,6 +332,8 @@ bool ResourceRequest::EqualsForTesting(const ResourceRequest& request) const {
              request.shared_dictionary_writer_enabled;
 }
 
+
+
 bool ResourceRequest::SendsCookies() const {
   return credentials_mode == network::mojom::CredentialsMode::kInclude;
 }
@@ -337,6 +343,8 @@ bool ResourceRequest::SavesCookies() const {
          !(load_flags & net::LOAD_DO_NOT_SAVE_COOKIES);
 }
 
+#include "base/logging.h"
+
 namespace mojo {
 
 template <>
@@ -252,6 +254,10 @@ struct COMPONENT_EXPORT(NETWORK_CPP_BASE)
       const network::ResourceRequest& request) {
     return request.credentials_mode;
   }
+  static network::mojom::ProtocolMode protocol_mode(
+      const network::ResourceRequest& request) {
+    return request.protocol_mode;
+  }
   static network::mojom::RedirectMode redirect_mode(
       const network::ResourceRequest& request) {
     return request.redirect_mode;
diff --git a/services/network/public/mojom/fetch_api.mojom b/services/network/public/mojom/fetch_api.mojom
index e4365f8ff7c8b..25270a9bff04b 100644
--- a/services/network/public/mojom/fetch_api.mojom
+++ b/services/network/public/mojom/fetch_api.mojom
@@ -85,6 +85,12 @@ enum RedirectMode {
   kManual,
 };
 
+enum ProtocolMode {
+  kHttp1,
+  kHttp2,
+  kHttp3,
+};
+
 // Corresponds to Fetch request's "credentials mode":
 // https://fetch.spec.whatwg.org/#concept-request-credentials-mode
 enum CredentialsMode {
diff --git a/services/network/public/mojom/url_request.mojom b/services/network/public/mojom/url_request.mojom
index 2e92cbc7bdb9b..1b1af821bfffe 100644
--- a/services/network/public/mojom/url_request.mojom
+++ b/services/network/public/mojom/url_request.mojom
@@ -305,6 +305,8 @@ struct URLRequest {
   // When |mode| is |kNavigate|, this needs to be |kInclude|.
   CredentialsMode credentials_mode;
 
+  ProtocolMode protocol_mode;
+
   // https://fetch.spec.whatwg.org/#concept-request-redirect-mode
   // Used mainly by CORS handling (out-of-blink CORS), Service Worker.
   // This member must be kFollow as long as |mode| is kNoCors.
diff --git a/services/network/url_loader.cc b/services/network/url_loader.cc
index 52f90133c5150..5b8f785f918b6 100644
--- a/services/network/url_loader.cc
+++ b/services/network/url_loader.cc
@@ -334,6 +334,7 @@ std::vector<mojom::WebClientHintsType> ComputeAcceptCHFrameHints(
 // Returns true if the |credentials_mode| of the request allows sending
 // credentials.
 bool ShouldAllowCredentials(mojom::CredentialsMode credentials_mode) {
+  // DVLOG(0) << "The credential mode at services-network-url-loader is: " << credentials_mode << std::endl;
   switch (credentials_mode) {
     case mojom::CredentialsMode::kInclude:
     // TODO(crbug.com/40619226): Make this work with
@@ -345,6 +346,19 @@ bool ShouldAllowCredentials(mojom::CredentialsMode credentials_mode) {
     case mojom::CredentialsMode::kOmitBug_775438_Workaround:
       return false;
   }
+ }
+
+bool ShouldAllowProtocol(mojom::ProtocolMode protocol_mode) {
+  // DVLOG(0) << "The protocol mode in services-network-url-loader-should-allow-protocol is: " << protocol_mode << std::endl;
+  switch (protocol_mode) {
+    case mojom::ProtocolMode::kHttp3:
+      return true;
+
+    case mojom::ProtocolMode::kHttp1:
+    case mojom::ProtocolMode::kHttp2:
+    default:
+      return false;
+  }
 }
 
 // Returns true when the |credentials_mode| of the request allows sending client
@@ -565,6 +579,7 @@ URLLoader::URLLoader(
       devtools_request_id_(request.devtools_request_id),
       request_mode_(request.mode),
       request_credentials_mode_(request.credentials_mode),
+      request_protocol_mode_(request.protocol_mode),
       request_destination_(request.destination),
       resource_scheduler_client_(context.GetResourceSchedulerClient()),
       keepalive_statistics_recorder_(std::move(keepalive_statistics_recorder)),
@@ -618,8 +633,9 @@ URLLoader::URLLoader(
       discard_buffer_ =
           base::MakeRefCounted<net::IOBufferWithSize>(kDiscardBufferSize);
     }
+  
   }
-
+  // DVLOG(0) << "THe request id in url loader is : " << request_id_ << std::endl;
   mojom::TrustedURLLoaderHeaderClient* url_loader_header_client =
       context.GetUrlLoaderHeaderClient();
   if (url_loader_header_client &&
@@ -742,6 +758,7 @@ URLLoader::URLLoader(
   url_request_->SetLoadFlags(request_load_flags);
   url_request_->SetPriorityIncremental(request.priority_incremental);
   SetRequestCredentials(request.url);
+  SetRequestProtocol(request.url);
 
   url_request_->SetRequestHeadersCallback(base::BindRepeating(
       &URLLoader::SetRawRequestHeadersAndNotify, base::Unretained(this)));
@@ -1511,6 +1528,7 @@ void URLLoader::OnReceivedRedirect(net::URLRequest* url_request,
   }
 
   SetRequestCredentials(redirect_info.new_url);
+  SetRequestProtocol(redirect_info.new_url);
 
   // Clear the Cookie header to ensure that cookies passed in through the
   // `ResourceRequest` do not persist across redirects.
@@ -2956,6 +2974,16 @@ void URLLoader::SetRequestCredentials(const GURL& url) {
   }
 }
 
+void URLLoader::SetRequestProtocol(const GURL& url) {
+  bool allow_protocol = ShouldAllowProtocol(request_protocol_mode_);
+
+  if (!allow_protocol)
+    // DVLOG(0) << "The allow protocol in services-network-url-loader is :" << allow_protocol << std::endl;
+    url_request_->set_allow_protocol(false);
+  if (allow_protocol)
+    url_request_->set_allow_protocol(true);
+} 
+
 // [spec]:
 // https://fetch.spec.whatwg.org/#cross-origin-embedder-policy-allows-credentials
 bool URLLoader::CoepAllowCredentials(const GURL& url) {
diff --git a/services/network/url_loader.h b/services/network/url_loader.h
index 28dc62a530ae5..a07fe0ab243a0 100644
--- a/services/network/url_loader.h
+++ b/services/network/url_loader.h
@@ -601,6 +601,10 @@ class COMPONENT_EXPORT(NETWORK_SERVICE) URLLoader
   // credentials and client certificates.
   void SetRequestCredentials(const GURL& url);
 
+  // Determine given the |url|, whether the |url_request_| should include
+  // protocol to be used.
+  void SetRequestProtocol(const GURL& url);
+
   // Returns whether sending/storing credentials is allowed by COEP.
   // |url| is the latest request URL, either the original URL or
   // `redirect_info.new_url`.
@@ -699,6 +703,7 @@ class COMPONENT_EXPORT(NETWORK_SERVICE) URLLoader
 
   const mojom::RequestMode request_mode_;
   const mojom::CredentialsMode request_credentials_mode_;
+  const mojom::ProtocolMode request_protocol_mode_;
 
   bool has_user_activation_ = false;
 
diff --git a/services/network/url_loader_factory.cc b/services/network/url_loader_factory.cc
index c8dbf2df3820e..407970d10e3b0 100644
--- a/services/network/url_loader_factory.cc
+++ b/services/network/url_loader_factory.cc
@@ -126,6 +126,7 @@ void URLLoaderFactory::CreateLoaderAndStart(
                                      resource_request, std::move(client),
                                      /* sync_client= */ nullptr,
                                      traffic_annotation);
+  // DVLOG(0) << "The protocol mode at url-loader-factory of services-network is: " << resource_request.protocol_mode << std::endl;
 }
 
 void URLLoaderFactory::Clone(
@@ -189,7 +190,6 @@ void URLLoaderFactory::CreateLoaderAndStartWithSyncClient(
   // Requests with |trusted_params| when params_->is_trusted is not set should
   // have been rejected at the CorsURLLoader layer.
   DCHECK(!resource_request.trusted_params || params_->is_trusted);
-
   if (resource_request.web_bundle_token_params.has_value() &&
       resource_request.destination !=
           network::mojom::RequestDestination::kWebBundle) {
diff --git a/third_party/blink/public/mojom/fetch/fetch_api_request.mojom b/third_party/blink/public/mojom/fetch/fetch_api_request.mojom
index de6ecb58729b5..df641570d5e9f 100644
--- a/third_party/blink/public/mojom/fetch/fetch_api_request.mojom
+++ b/third_party/blink/public/mojom/fetch/fetch_api_request.mojom
@@ -103,6 +103,12 @@ enum FetchCacheMode {
   kUnspecifiedForceCacheMiss,
 };
 
+enum TempTest {
+  kH2,
+  kAuto,
+  kH3
+};
+
 // Corresponds to Fetch request's "priority"
 // Spec: https://wicg.github.io/priority-hints/
 enum FetchPriorityHint {
diff --git a/third_party/blink/public/platform/web_url_request.h b/third_party/blink/public/platform/web_url_request.h
index be5eb0a20ff74..99035b0eba4ce 100644
--- a/third_party/blink/public/platform/web_url_request.h
+++ b/third_party/blink/public/platform/web_url_request.h
@@ -47,6 +47,7 @@ namespace network {
 namespace mojom {
 enum class CorsPreflightPolicy : int32_t;
 enum class CredentialsMode : int32_t;
+enum class ProtocolMode : int32_t;
 enum class RedirectMode : int32_t;
 enum class ReferrerPolicy : int32_t;
 enum class RequestMode : int32_t;
@@ -147,6 +148,9 @@ class BLINK_PLATFORM_EXPORT WebURLRequest {
   WebHTTPBody AttachedCredential() const;
   void SetAttachedCredential(const WebHTTPBody&);
 
+  WebHTTPBody AttachedProtocol() const;
+  void SetAttachedProtocol(const WebHTTPBody&);
+
   // Controls whether upload progress events are generated when a request
   // has a body.
   bool ReportUploadProgress() const;
@@ -207,6 +211,9 @@ class BLINK_PLATFORM_EXPORT WebURLRequest {
   network::mojom::CredentialsMode GetCredentialsMode() const;
   void SetCredentialsMode(network::mojom::CredentialsMode);
 
+  network::mojom::ProtocolMode GetProtocolMode() const;
+  void SetProtocolMode(network::mojom::ProtocolMode);
+
   // The redirect mode which is used in Fetch API.
   network::mojom::RedirectMode GetRedirectMode() const;
   void SetRedirectMode(network::mojom::RedirectMode);
diff --git a/third_party/blink/renderer/core/loader/web_associated_url_loader_impl.cc b/third_party/blink/renderer/core/loader/web_associated_url_loader_impl.cc
index f3d3a626c73a9..c42ea75dedf85 100644
--- a/third_party/blink/renderer/core/loader/web_associated_url_loader_impl.cc
+++ b/third_party/blink/renderer/core/loader/web_associated_url_loader_impl.cc
@@ -109,6 +109,7 @@ class WebAssociatedURLLoaderImpl::ClientAdapter final
                 const WebAssociatedURLLoaderOptions&,
                 network::mojom::RequestMode,
                 network::mojom::CredentialsMode,
+                network::mojom::ProtocolMode,
                 scoped_refptr<base::SingleThreadTaskRunner>);
   ClientAdapter(const ClientAdapter&) = delete;
   ClientAdapter& operator=(const ClientAdapter&) = delete;
@@ -159,6 +160,7 @@ class WebAssociatedURLLoaderImpl::ClientAdapter final
   WebAssociatedURLLoaderOptions options_;
   network::mojom::RequestMode request_mode_;
   network::mojom::CredentialsMode credentials_mode_;
+  network::mojom::ProtocolMode protocol_mode_;
   std::optional<WebURLError> error_;
 
   HeapTaskRunnerTimer<ClientAdapter> error_timer_;
@@ -172,12 +174,14 @@ WebAssociatedURLLoaderImpl::ClientAdapter::ClientAdapter(
     const WebAssociatedURLLoaderOptions& options,
     network::mojom::RequestMode request_mode,
     network::mojom::CredentialsMode credentials_mode,
+    network::mojom::ProtocolMode protocol_mode,
     scoped_refptr<base::SingleThreadTaskRunner> task_runner)
     : loader_(loader),
       client_(client),
       options_(options),
       request_mode_(request_mode),
       credentials_mode_(credentials_mode),
+      protocol_mode_(protocol_mode),
       error_timer_(std::move(task_runner), this, &ClientAdapter::NotifyError),
       enable_error_notifications_(false),
       did_fail_(false) {
@@ -400,7 +404,7 @@ void WebAssociatedURLLoaderImpl::LoadAsynchronously(
       observer_->GetExecutionContext()->GetTaskRunner(
           TaskType::kInternalLoading);
   client_adapter_ = MakeGarbageCollected<ClientAdapter>(
-      this, client, options_, request.GetMode(), request.GetCredentialsMode(),
+      this, client, options_, request.GetMode(), request.GetCredentialsMode(), request.GetProtocolMode(),
       std::move(task_runner));
 
   if (allow_load) {
diff --git a/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc b/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc
index 102044ea56d8b..45364af86991e 100644
--- a/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc
+++ b/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc
@@ -552,6 +552,7 @@ void XMLHttpRequest::setResponseType(const String& response_type,
   }
 }
 
+
 String XMLHttpRequest::responseType() {
   switch (response_type_code_) {
     case kResponseTypeDefault:
@@ -577,6 +578,44 @@ String XMLHttpRequest::responseURL() {
   return response_url.GetString();
 }
 
+
+void XMLHttpRequest::setProtocol(const String& protocol,
+                                     ExceptionState& exception_state) {
+
+  if (state_ > kOpened || send_flag_) {
+    exception_state.ThrowDOMException(
+        DOMExceptionCode::kInvalidStateError,
+        "The value may only be set if the object's state is UNSENT or OPENED.");
+    return;
+  }
+   
+  DVLOG(0) << "The protocol field is : " << protocol << std::endl;
+
+  if (protocol == "") {
+    protocol_ = kHttp1;
+  } else if (protocol == "http2") {
+    protocol_ = kHttp2;
+  } else if (protocol == "http3") {
+    protocol_ = kHttp3;
+  } else {
+    NOTREACHED_IN_MIGRATION();
+  }
+}
+
+String XMLHttpRequest::protocol() {
+  switch (protocol_) {
+    case kHttp1:
+      return "";
+    case kHttp2:
+      return "http2";
+    case kHttp3:
+      return "http3";
+  }
+  return "";
+}
+
+
+
 XMLHttpRequestUpload* XMLHttpRequest::upload() {
   if (!upload_)
     upload_ = MakeGarbageCollected<XMLHttpRequestUpload>(this);
@@ -642,6 +681,21 @@ void XMLHttpRequest::setWithCredentials(bool value,
   with_credentials_ = value;
 }
 
+
+// void XMLHttpRequest::setProtocol(bool protocol,
+//                                  ExceptionState& exception_state) {
+
+//   if (state_ > kOpened || send_flag_) {
+//     exception_state.ThrowDOMException(
+//         DOMExceptionCode::kInvalidStateError,
+//         "The value may only be set if the object's state is UNSENT or OPENED.");
+//     return;
+//   }
+  
+//   protocol_ = protocol;
+
+// }
+
 void XMLHttpRequest::open(const AtomicString& method,
                           const String& url_string,
                           ExceptionState& exception_state) {
@@ -1109,6 +1163,14 @@ void XMLHttpRequest::CreateRequest(scoped_refptr<EncodedFormData> http_body,
   request.SetCredentialsMode(
       with_credentials_ ? network::mojom::CredentialsMode::kInclude
                         : network::mojom::CredentialsMode::kSameOrigin);
+  
+  if(protocol_ == kHttp2){
+    request.SetProtocolMode(network::mojom::ProtocolMode::kHttp2);
+  }
+  if(protocol_ == kHttp3){
+    request.SetProtocolMode(network::mojom::ProtocolMode::kHttp3);
+  }
+  
   request.SetSkipServiceWorker(world_ && world_->IsIsolatedWorld());
   if (trust_token_params_)
     request.SetTrustTokenParams(*trust_token_params_);
diff --git a/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.h b/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.h
index 4cfaa6e73e9ce..224b853d07e82 100644
--- a/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.h
+++ b/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.h
@@ -112,6 +112,12 @@ class CORE_EXPORT XMLHttpRequest final
     kResponseTypeArrayBuffer,
   };
 
+  enum Protocol {
+    kHttp1,
+    kHttp2,
+    kHttp3,
+  };
+
   // ExecutionContextLifecycleObserver
   void ContextDestroyed() override;
   ExecutionContext* GetExecutionContext() const override;
@@ -127,6 +133,7 @@ class CORE_EXPORT XMLHttpRequest final
   String statusText() const;
   int status() const;
   State readyState() const;
+
   bool withCredentials() const { return with_credentials_; }
   void setWithCredentials(bool, ExceptionState&);
   void open(const AtomicString& method, const String& url, ExceptionState&);
@@ -165,6 +172,10 @@ class CORE_EXPORT XMLHttpRequest final
   void setResponseType(const String&, ExceptionState&);
   String responseURL();
 
+  Protocol GetProtocol() const { return protocol_;}
+  String protocol();
+  void setProtocol(const String&, ExceptionState&);
+
   // For Inspector.
   void SendForInspectorXHRReplay(scoped_refptr<EncodedFormData>,
                                  ExceptionState&);
@@ -353,6 +364,7 @@ class CORE_EXPORT XMLHttpRequest final
   // An enum corresponding to the allowed string values for the responseType
   // attribute.
   ResponseTypeCode response_type_code_ = kResponseTypeDefault;
+  Protocol protocol_ = kHttp1;
 
   // The DOMWrapperWorld in which the request initiated. Can be null.
   Member<const DOMWrapperWorld> world_;
@@ -367,6 +379,8 @@ class CORE_EXPORT XMLHttpRequest final
   Member<scheduler::TaskAttributionInfo> parent_task_;
 
   bool async_ = true;
+  
+  // bool protocol_ = false;
 
   bool with_credentials_ = false;
 
diff --git a/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.idl b/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.idl
index bec5662779647..a6941b478f9b9 100644
--- a/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.idl
+++ b/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.idl
@@ -61,6 +61,9 @@ typedef (Blob or BufferSource or FormData or URLSearchParams or USVString) XMLHt
     [RaisesException] void open(ByteString method, USVString url, boolean async, optional USVString? username = null, optional USVString? password = null);
     [RaisesException] void setRequestHeader(ByteString name, ByteString value);
     [RaisesException, RuntimeEnabled=PrivateStateTokens, SecureContext, MeasureAs=TrustTokenXhr] void setPrivateToken(PrivateToken privateToken);
+    //newly added
+    [RaisesException=Setter] attribute DOMString protocol;
+    
     [RaisesException, RuntimeEnabled=AttributionReportingInterface, SecureContext] void setAttributionReporting(AttributionReportingRequestOptions attributionReporting);
     [RaisesException=Setter] attribute unsigned long timeout;
     [RaisesException=Setter] attribute boolean withCredentials;
diff --git a/third_party/blink/renderer/platform/exported/web_url_request.cc b/third_party/blink/renderer/platform/exported/web_url_request.cc
index 4b0fe719d4319..d14e4d0e5724d 100644
--- a/third_party/blink/renderer/platform/exported/web_url_request.cc
+++ b/third_party/blink/renderer/platform/exported/web_url_request.cc
@@ -335,6 +335,14 @@ void WebURLRequest::SetCredentialsMode(network::mojom::CredentialsMode mode) {
   return resource_request_->SetCredentialsMode(mode);
 }
 
+network::mojom::ProtocolMode WebURLRequest::GetProtocolMode() const {
+  return resource_request_->GetProtocolMode();
+}
+
+void WebURLRequest::SetProtocolMode(network::mojom::ProtocolMode mode) {
+  return resource_request_->SetProtocolMode(mode);
+}
+
 network::mojom::RedirectMode WebURLRequest::GetRedirectMode() const {
   return resource_request_->GetRedirectMode();
 }
diff --git a/third_party/blink/renderer/platform/loader/fetch/resource.cc b/third_party/blink/renderer/platform/loader/fetch/resource.cc
index 406696ca0a95d..6a36ebe4a4b8f 100644
--- a/third_party/blink/renderer/platform/loader/fetch/resource.cc
+++ b/third_party/blink/renderer/platform/loader/fetch/resource.cc
@@ -791,6 +791,12 @@ Resource::MatchStatus Resource::CanReuse(const FetchParameters& params) const {
     return MatchStatus::kRequestCredentialsModeDoesNotMatch;
   }
 
+  if (current_request.GetProtocolMode() !=
+      new_request.GetProtocolMode()) {
+    return MatchStatus::kRequestProtocolModeDoesNotMatch;
+  }
+
+  
   // Certain requests (e.g., XHRs) might have manually set headers that require
   // revalidation. In theory, this should be a Revalidate case. In practice, the
   // MemoryCache revalidation path assumes a whole bunch of things about how
@@ -853,6 +859,11 @@ Resource::MatchStatus Resource::CanReuse(const FetchParameters& params) const {
     return MatchStatus::kRequestCredentialsModeDoesNotMatch;
   }
 
+  if (new_request.GetProtocolMode() !=
+      current_request.GetProtocolMode()) {
+    return MatchStatus::kRequestProtocolModeDoesNotMatch;
+  }
+
   const auto new_mode = new_request.GetMode();
   const auto existing_mode = current_request.GetMode();
 
diff --git a/third_party/blink/renderer/platform/loader/fetch/resource.h b/third_party/blink/renderer/platform/loader/fetch/resource.h
index cddc99183e333..26e60275c3e14 100644
--- a/third_party/blink/renderer/platform/loader/fetch/resource.h
+++ b/third_party/blink/renderer/platform/loader/fetch/resource.h
@@ -143,6 +143,9 @@ class PLATFORM_EXPORT Resource : public GarbageCollected<Resource>,
     // Match fails due to different request credentials modes.
     kRequestCredentialsModeDoesNotMatch,
 
+    // Match fails due to different request credentials modes.
+    kRequestProtocolModeDoesNotMatch,
+
     // Match fails because keepalive flag is set on either requests.
     kKeepaliveSet,
 
diff --git a/third_party/blink/renderer/platform/loader/fetch/resource_fetcher.cc b/third_party/blink/renderer/platform/loader/fetch/resource_fetcher.cc
index f4b39eca92b4c..366519f840386 100644
--- a/third_party/blink/renderer/platform/loader/fetch/resource_fetcher.cc
+++ b/third_party/blink/renderer/platform/loader/fetch/resource_fetcher.cc
@@ -1860,6 +1860,10 @@ void ResourceFetcher::PrintPreloadMismatch(Resource* resource,
       builder.Append("because the request credentials mode does not match. ");
       builder.Append("Consider taking a look at crossorigin attribute.");
       break;
+    case Resource::MatchStatus::kRequestProtocolModeDoesNotMatch:
+      builder.Append("because the request protocol mode does not match. ");
+      builder.Append("Consider taking a look at crossorigin attribute.");
+      break;
     case Resource::MatchStatus::kKeepaliveSet:
       builder.Append("because the keepalive flag is set.");
       break;
diff --git a/third_party/blink/renderer/platform/loader/fetch/resource_loader.cc b/third_party/blink/renderer/platform/loader/fetch/resource_loader.cc
index edfa76bb4c064..0e0e4b93997c3 100644
--- a/third_party/blink/renderer/platform/loader/fetch/resource_loader.cc
+++ b/third_party/blink/renderer/platform/loader/fetch/resource_loader.cc
@@ -650,6 +650,8 @@ bool ResourceLoader::WillFollowRedirect(
   network::mojom::RequestMode request_mode = initial_request.GetMode();
   network::mojom::CredentialsMode credentials_mode =
       initial_request.GetCredentialsMode();
+  network::mojom::ProtocolMode protocol_mode =
+      initial_request.GetProtocolMode();
 
   const ResourceLoaderOptions& options = resource_->Options();
 
@@ -735,6 +737,8 @@ bool ResourceLoader::WillFollowRedirect(
   DCHECK_EQ(new_request->GetRequestContext(), request_context);
   DCHECK_EQ(new_request->GetMode(), request_mode);
   DCHECK_EQ(new_request->GetCredentialsMode(), credentials_mode);
+  DCHECK_EQ(new_request->GetProtocolMode(), protocol_mode);
+
 
   // If `Shared-Storage-Writable` eligibity has changed, update the headers.
   bool previous_shared_storage_writable_eligible =
diff --git a/third_party/blink/renderer/platform/loader/fetch/resource_request.cc b/third_party/blink/renderer/platform/loader/fetch/resource_request.cc
index 257e31421be33..191106cfc9825 100644
--- a/third_party/blink/renderer/platform/loader/fetch/resource_request.cc
+++ b/third_party/blink/renderer/platform/loader/fetch/resource_request.cc
@@ -40,6 +40,7 @@
 #include "third_party/blink/renderer/platform/network/http_names.h"
 #include "third_party/blink/renderer/platform/network/network_utils.h"
 #include "third_party/blink/renderer/platform/weborigin/referrer.h"
+#include "base/logging.h"
 
 namespace blink {
 
@@ -114,6 +115,7 @@ ResourceRequestHead::ResourceRequestHead(const KURL& url)
       mode_(network::mojom::RequestMode::kNoCors),
       fetch_priority_hint_(mojom::blink::FetchPriorityHint::kAuto),
       credentials_mode_(network::mojom::CredentialsMode::kInclude),
+      protocol_mode_(network::mojom::ProtocolMode::kHttp3),
       redirect_mode_(network::mojom::RedirectMode::kFollow),
       referrer_string_(Referrer::ClientReferrerString()),
       referrer_policy_(network::mojom::ReferrerPolicy::kDefault),
@@ -207,6 +209,7 @@ std::unique_ptr<ResourceRequest> ResourceRequestHead::CreateRedirectRequest(
   request->SetMode(GetMode());
   request->SetTargetAddressSpace(GetTargetAddressSpace());
   request->SetCredentialsMode(GetCredentialsMode());
+  request->SetProtocolMode(GetProtocolMode());
   request->SetKeepalive(GetKeepalive());
   request->SetBrowsingTopics(GetBrowsingTopics());
   request->SetAdAuctionHeaders(GetAdAuctionHeaders());
diff --git a/third_party/blink/renderer/platform/loader/fetch/resource_request.h b/third_party/blink/renderer/platform/loader/fetch/resource_request.h
index 63e329ccb9eab..17a7e63b26a85 100644
--- a/third_party/blink/renderer/platform/loader/fetch/resource_request.h
+++ b/third_party/blink/renderer/platform/loader/fetch/resource_request.h
@@ -387,6 +387,14 @@ class PLATFORM_EXPORT ResourceRequestHead {
     credentials_mode_ = mode;
   }
 
+  network::mojom::ProtocolMode GetProtocolMode() const {
+    return protocol_mode_;
+  }
+  void SetProtocolMode(network::mojom::ProtocolMode mode) {
+    protocol_mode_ = mode;
+    // DVLOG(0) << "The protocol field is set till resource request mera kaam ho gyaaaaaa okayyyy: " << protocol_mode_ << std::endl;
+  }
+
   network::mojom::RedirectMode GetRedirectMode() const {
     return redirect_mode_;
   }
@@ -688,6 +696,7 @@ class PLATFORM_EXPORT ResourceRequestHead {
   network::mojom::RequestMode mode_;
   mojom::blink::FetchPriorityHint fetch_priority_hint_;
   network::mojom::CredentialsMode credentials_mode_;
+  network::mojom::ProtocolMode protocol_mode_;
   network::mojom::RedirectMode redirect_mode_;
   // Exposed as Request.integrity in Service Workers
   String fetch_integrity_;
diff --git a/third_party/blink/renderer/platform/loader/fetch/url_loader/request_conversion.cc b/third_party/blink/renderer/platform/loader/fetch/url_loader/request_conversion.cc
index eba2a99108306..012173224237c 100644
--- a/third_party/blink/renderer/platform/loader/fetch/url_loader/request_conversion.cc
+++ b/third_party/blink/renderer/platform/loader/fetch/url_loader/request_conversion.cc
@@ -332,6 +332,7 @@ void PopulateResourceRequest(const ResourceRequestHead& src,
   dest->mode = src.GetMode();
   dest->destination = src.GetRequestDestination();
   dest->credentials_mode = src.GetCredentialsMode();
+  dest->protocol_mode = src.GetProtocolMode();
   dest->redirect_mode = src.GetRedirectMode();
   dest->fetch_integrity = src.GetFetchIntegrity().Utf8();
   if (src.GetWebBundleTokenParams().has_value()) {
@@ -394,6 +395,8 @@ void PopulateResourceRequest(const ResourceRequestHead& src,
   network::mojom::RequestDestination request_destination =
       src.GetRequestDestination();
   network_utils::SetAcceptHeader(dest->headers, request_destination);
+  
+  // DVLOG(0) << "The request destination is: " << request_destination << std::endl;
 
   dest->original_destination = src.GetOriginalDestination();
 
diff --git a/third_party/blink/renderer/platform/loader/fetch/url_loader/url_loader.cc b/third_party/blink/renderer/platform/loader/fetch/url_loader/url_loader.cc
index 8e0ba65674448..ba95182f428ca 100644
--- a/third_party/blink/renderer/platform/loader/fetch/url_loader/url_loader.cc
+++ b/third_party/blink/renderer/platform/loader/fetch/url_loader/url_loader.cc
@@ -301,6 +301,8 @@ void URLLoader::Context::Start(
           &BackForwardCacheLoaderHelper::DidBufferLoadWhileInBackForwardCache,
           back_forward_cache_loader_helper_,
           /*update_process_wide_count=*/true));
+  
+  // DVLOG(0) << "The request id is: " << request_id_ << std::endl;
 
   if (freeze_mode_ != LoaderFreezeMode::kNone) {
     resource_request_sender_->Freeze(LoaderFreezeMode::kStrict);
